// This file is part of libigl, a simple c++ geometry processing library.
//
// Copyright (C) 2013 Alec Jacobson <alecjacobson@gmail.com>
//
// This Source Code Form is subject to the terms of the Mozilla Public License
// v. 2.0. If a copy of the MPL was not distributed with this file, You can
// obtain one at http://mozilla.org/MPL/2.0/.
#include "reorder.h"
#include "SortableRow.h"
#ifndef IGLAABB_NO_EIGEN
#include <Eigen/Core>
#endif

// This implementation is O(n), but also uses O(n) extra memory
template< class T >
IGLAABB_INLINE void iglaabb::reorder(
  const std::vector<T> & unordered,
  std::vector<size_t> const & index_map,
  std::vector<T> & ordered)
{
  // copy for the reorder according to index_map, because unsorted may also be
  // sorted
  std::vector<T> copy = unordered;
  ordered.resize(index_map.size());
  for(int i = 0; i<(int)index_map.size();i++)
  {
    ordered[i] = copy[index_map[i]];
  }
}

#ifdef IGLAABB_STATIC_LIBRARY
// Explicit template instantiation
// generated by autoexplicit.sh
template void iglaabb::reorder<unsigned int>(std::vector<unsigned int, std::allocator<unsigned int> > const&, std::vector<unsigned long, std::allocator<unsigned long> > const&, std::vector<unsigned int, std::allocator<unsigned int> >&);
// generated by autoexplicit.sh
template void iglaabb::reorder<float>(std::vector<float, std::allocator<float> > const&, std::vector<size_t, std::allocator<size_t> > const&, std::vector<float, std::allocator<float> >&);
template void iglaabb::reorder<double>(std::vector<double, std::allocator<double> > const&, std::vector<size_t, std::allocator<size_t> > const&, std::vector<double, std::allocator<double> >&);
template void iglaabb::reorder<int>(std::vector<int, std::allocator<int> > const&, std::vector<size_t, std::allocator<size_t> > const&, std::vector<int, std::allocator<int> >&);
#  ifndef IGLAABB_NO_EIGEN
  template void iglaabb::reorder<iglaabb::SortableRow<Eigen::Matrix<int, -1, 1, 0, -1, 1> > >(std::vector<iglaabb::SortableRow<Eigen::Matrix<int, -1, 1, 0, -1, 1> >, std::allocator<iglaabb::SortableRow<Eigen::Matrix<int, -1, 1, 0, -1, 1> > > > const&, std::vector<size_t, std::allocator<size_t> > const&, std::vector<iglaabb::SortableRow<Eigen::Matrix<int, -1, 1, 0, -1, 1> >, std::allocator<iglaabb::SortableRow<Eigen::Matrix<int, -1, 1, 0, -1, 1> > > >&);
  template void iglaabb::reorder<iglaabb::SortableRow<Eigen::Matrix<double, -1, 1, 0, -1, 1> > >(std::vector<iglaabb::SortableRow<Eigen::Matrix<double, -1, 1, 0, -1, 1> >, std::allocator<iglaabb::SortableRow<Eigen::Matrix<double, -1, 1, 0, -1, 1> > > > const&, std::vector<size_t, std::allocator<size_t> > const&, std::vector<iglaabb::SortableRow<Eigen::Matrix<double, -1, 1, 0, -1, 1> >, std::allocator<iglaabb::SortableRow<Eigen::Matrix<double, -1, 1, 0, -1, 1> > > >&);
#  endif
template void iglaabb::reorder<long>(std::vector<long, std::allocator<long> > const&, std::vector<size_t, std::allocator<size_t> > const&, std::vector<long, std::allocator<long> >&);
#ifdef WIN32
template void iglaabb::reorder<unsigned int>(class std::vector<unsigned int,class std::allocator<unsigned int> > const &,class std::vector<unsigned __int64,class std::allocator<unsigned __int64> > const &,class std::vector<unsigned int,class std::allocator<unsigned int> > &);
template void iglaabb::reorder<float>(class std::vector<float,class std::allocator<float> > const &,class std::vector<unsigned __int64,class std::allocator<unsigned __int64> > const &,class std::vector<float,class std::allocator<float> > &);
template void iglaabb::reorder<__int64>(class std::vector<__int64,class std::allocator<__int64> > const &,class std::vector<unsigned __int64,class std::allocator<unsigned __int64> > const &,class std::vector<__int64,class std::allocator<__int64> > &);
#endif
#endif
